# -*- coding: utf-8 -*-
"""ASSIGNMENT 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IxAo6z86CCTrEQ5GxXeHpsQLveDk595M
"""

# taking input
score = float(input("Enter the student's score (0-100): "))

# check whether the score is within the range (0-100)
if score < 0 or score > 100:
    print("Invalid score. Please enter a value between 0 and 100.")
else:
    # Determine the grade
    if score > 90:
        grade = "A"
    elif score >= 80:
        grade = "B"
    elif score >= 70:
        grade = "C"
    elif score >= 60:
        grade = "D"
    else:
        grade = "F"

    # Output the grade
    print(f"Grade: {grade}")

# input for the total amount spent
total_amount = float(input("Enter the total amount spent: "))

# Determine the discount rate based on the total amount
if total_amount > 500:
    discount_rate = 0.20  # 20% discount
elif 200 <= total_amount <= 500:
    discount_rate = 0.10  # 10% discount
else:
    discount_rate = 0  # No discount

# Calculate the discount amount
discount = total_amount * discount_rate

# Calculate the final amount after discount
final_amount = total_amount - discount

# Output
print(f"Original amount: ${total_amount:.2f}")
print(f"Discount applied: ${discount:.2f} ({discount_rate * 100}% off)")
print(f"Final amount after discount: ${final_amount:.2f}")

#function to determine the zodiac sign based on the month and day
def get_zodiac_sign(month, day):
    if (month == 1 and day >= 20) or (month == 2 and day <= 18):
        return "Aquarius"
    elif (month == 2 and day >= 19) or (month == 3 and day <= 20):
        return "Pisces"
    elif (month == 3 and day >= 21) or (month == 4 and day <= 19):
        return "Aries"
    elif (month == 4 and day >= 20) or (month == 5 and day <= 20):
        return "Taurus"
    elif (month == 5 and day >= 21) or (month == 6 and day <= 20):
        return "Gemini"
    elif (month == 6 and day >= 21) or (month == 7 and day <= 22):
        return "Cancer"
    elif (month == 7 and day >= 23) or (month == 8 and day <= 22):
        return "Leo"
    elif (month == 8 and day >= 23) or (month == 9 and day <= 22):
        return "Virgo"
    elif (month == 9 and day >= 23) or (month == 10 and day <= 22):
        return "Libra"
    elif (month == 10 and day >= 23) or (month == 11 and day <= 21):
        return "Scorpio"
    elif (month == 11 and day >= 22) or (month == 12 and day <= 21):
        return "Sagittarius"
    elif (month == 12 and day >= 22) or (month == 1 and day <= 19):
        return "Capricorn"
    else:
        return "Invalid date"

# Get the user's birth month and day
try:
    month = int(input("Enter your birth month (1-12): "))
    day = int(input("Enter your birth day: "))

    # Validate the month and day input
    if month < 1 or month > 12:
        print("Invalid month. Please enter a value between 1 and 12.")
    elif day < 1 or (month == 2 and day > 29) or (month in [4, 6, 9, 11] and day > 30) or (month in [1, 3, 5, 7, 8, 10, 12] and day > 31):
        print("Invalid day for the given month.")
    else:
        # Determine the zodiac sign
        zodiac_sign = get_zodiac_sign(month, day)
        print(f"Your zodiac sign is: {zodiac_sign}")

except ValueError:
    print("Invalid input. Please enter numeric values for month and day.")

import re #regular expressions

def is_valid_password(password):
    # Check for minimum and maximum length
    if len(password) < 6 or len(password) > 16:
        return False

    # Check for at least one lowercase letter
    if not re.search(r"[a-z]", password):
        return False

    # Check for at least one uppercase letter
    if not re.search(r"[A-Z]", password):
        return False

    # Check for at least one digit
    if not re.search(r"[0-9]", password):
        return False

    # Check for at least one special character ($#@)
    if not re.search(r"[$#@]", password):
        return False

    return True
# Prompt the user to enter a password
password = input("Enter a password: ")
# Check if the password is valid
if is_valid_password(password):
    print("Password is valid.")
else:
    print("Password is not valid. Ensure it meets the following criteria:\n"
          "- At least 6 characters and not more than 16 characters.\n"
          "- At least one lowercase letter [a-z].\n"
          "- At least one uppercase letter [A-Z].\n"
          "- At least one digit [0-9].\n"
          "- At least one special character from [$#@].")

import random

# Set a random target number between 1 and 100
target_number = random.randint(1, 100)

print("Welcome to the number guessing game!")
print("I have selected a number between 1 and 100. Try to guess it!")

# Start a while loop to allow multiple guesses
while True:
    # Ask the user for their guess
    try:
        user_guess = int(input("Enter your guess: "))

        # Provide feedback on the guess
        if user_guess < target_number:
            print("Too low! Try again.")
        elif user_guess > target_number:
            print("Too high! Try again.")
        else:
            print(f"Congratulations! You guessed the correct number: {target_number}")
            break  # Exit the loop when the guess is correct
    except ValueError:
        print("Invalid input. Please enter a whole number.")

# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True  # 2 and 3 are prime numbers
    if n % 2 == 0 or n % 3 == 0:
        return False  # Multiples of 2 and 3 are not prime

    # Check divisibility by all odd numbers from 5 to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
# Ask the user for a range
try:
    start = int(input("Enter the start of the range: "))
    end = int(input("Enter the end of the range: "))

    if start > end:
        print("Start of the range should be less than or equal to the end.")
    else:
        print(f"Prime numbers between {start} and {end}:")

        # Iterate through the range and print prime numbers
        for num in range(start, end + 1):
            if is_prime(num):
                print(num)
            else:
                continue  # Continue to the next iteration if not prime
except ValueError:
    print("Invalid input. Please enter whole numbers for the range.")

# Define a list of numbers
numbers = [22, 11, 10, 40, -27, 25, 35]

# Initialize a variable to hold the running sum
total_sum = 0

# Iterate through the list of numbers
for number in numbers:
    # If a negative number is encountered, break the loop
    if number < 0:
        print(f"Encountered a negative number ({number}). Stopping calculation.")
        break

    # Add the current number to the running sum
    total_sum += number

# Output the current sum
print(f"The sum of the numbers up to the negative value is: {total_sum}")

# Function to print the Right Pascal's Triangle
def print_right_pascals_triangle(rows):
    # First part: Increasing triangle
    for i in range(1, rows + 1):
        # Print numbers from 1 to i
        for j in range(1, i + 1):
            print(j, end=" ")  # Print each number followed by a space
        print()  # Move to the next line

    # Second part: Decreasing triangle
    for i in range(rows - 1, 0, -1):
        # Print numbers from 1 to i
        for j in range(1, i + 1):
            print(j, end=" ")  # Print each number followed by a space
        print()  # Move to the next line

# Ask the user for the number of rows
try:
    rows = int(input("Enter the number of rows for the Right Pascal's Triangle: "))

    if rows < 1:
        print("Please enter a positive number of rows.")
    else:
        # Print the Right Pascal's Triangle
        print_right_pascals_triangle(rows)

except ValueError:
    print("Invalid input. Please enter an integer.")

# Function to print the left half triangle with sequential numbers
def print_left_half_triangle(rows):
    # Start with a number and increment it with each iteration
    current_number = 1
    # Loop through each row
    for i in range(1, rows + 1):
        # Print the numbers for each row
        for j in range(i):
            print(current_number, end=" ")  # Print the current number followed by a space
            current_number += 1  # Increment the number
        print()  # Move to the next line after each row
# Ask the user for the number of rows
try:
    rows = int(input("Enter the number of rows for the left half triangle: "))

    if rows < 1:
        print("Please enter a positive number of rows.")
    else:
        # Print the left half triangle
        print_left_half_triangle(rows)
except ValueError:
    print("Invalid input. Please enter an integer.")

# Function to find numbers divisible by a given divisor within a specified range
def print_divisible_numbers(start, end, divisor):
    # Loop through the range of numbers
    for num in range(start, end + 1):
        # Check if the number is divisible by the divisor
        if num % divisor == 0:
            print(num, end=" ")  # Print the number followed by a space
    print()
# Ask the user for two numbers to define the range
try:
    start = int(input("Enter the first number to define the range: "))
    end = int(input("Enter the second number to define the range: "))

    if start > end:
        # Ensure the first number is less than or equal to the second number
        start, end = end, start  # Swap if the start is greater than the end
    # Ask for the divisor
    divisor = int(input("Enter the divisor: "))
    if divisor == 0:
        print("Divisor cannot be zero.")
    else:
        print(f"Numbers between {start} and {end} that are divisible by {divisor}:")
        # Print the numbers in the range that are divisible by the divisor
        print_divisible_numbers(start, end, divisor)
except ValueError:
    print("Invalid input. Please enter valid integers.")

# Recursive function to reverse a string
def reverse_string(s):
    # Base case: if the string is empty or has only one character
    if len(s) <= 1:
        return s  # A single character or empty string is its own reverse

    # Recursive case: reverse the rest of the string and add the first character to the end
    return reverse_string(s[1:]) + s[0]


input_string = input("Enter a string")
reversed_string = reverse_string(input_string)

print(f"Original string: {input_string}")
print(f"Reversed string: {reversed_string}")

# Function to find the longest word in a given sentence
def longest_word(sentence):
    # Split the sentence into words based on whitespace
    words = sentence.split()
    # Initialize variables to track the longest word and its length
    longest = ""
    max_length = 0
    # Loop through the words to find the longest one
    for word in words:
        word_length = len(word)  # Get the length of the current word

        if word_length > max_length:
            # If the current word is longer, update the longest and max_length
            longest = word
            max_length = word_length

    return longest
sentence = input("enter the sentence: ")
longest = longest_word(sentence)

print(f"The longest word in the sentence '{sentence}' is '{longest}'")

# Define the custom sorting function
def custom_sort(tuples_list):
    # Sort by score (descending), then by name (ascending) for ties
    return sorted(tuples_list, key=lambda x: (-x[1], x[0]))

# Sample input list of tuples (name, score)
sample_data = [('Alice', 88), ('Bob', 95), ('Charlie', 88), ('Dave', 95)]

# Apply the custom sorting function
sorted_list = custom_sort(sample_data)

# Output the sorted list
print("Sorted list:", sorted_list)

# Function to transform a given string as specified
def transform_string(s):
    # Initialize an empty list
    transformed = []
    # Variable to keep track of whether the letter should be capitalized
    capitalize = True
    # Iterate through each character in the input string
    for char in s:
        if char.isalpha():
            if capitalize:
                transformed.append(char.upper())  # Capitalize
            else:
                transformed.append(char.lower())  # Keep the letter in lowercase
            # Toggle capitalization for the next letter
            capitalize = not capitalize
        elif char == " ":  # If it's a space, replace it with a hyphen
            transformed.append("-")
        else:
            # If it's any other character, just add it to the list
            transformed.append(char)
    # Join the list to form the transformed string
    return "".join(transformed)
# Ask the user for a string to transform
user_input = input("Enter a string to transform: ")

# Transform the input string
result = transform_string(user_input)

# Output the transformed string
print("Transformed string:", result)

# Function to simulate renaming files with a given template
def simulate_file_renaming(filenames, name_template):
    # Count the number of "#" in the template to determine the number of digits for numbering
    num_placeholders = name_template.count("#")

    # Split the template at the "#" to insert numbers
    parts = name_template.split("#" * num_placeholders)

    # Generate new filenames based on the given template
    new_filenames = []
    for i, filename in enumerate(filenames):
        # Format the number with leading zeros according to the number of placeholders
        formatted_number = f"{i + 1:0{num_placeholders}}"

        # Construct the new name by inserting the formatted number into the template
        new_filename = parts[0] + formatted_number + parts[1]

        # Keep the original file extension
        original_extension = filename.split(".")[-1]
        new_filename += f".{original_extension}"

        new_filenames.append(new_filename)

    return new_filenames

# Example usage
filenames = ['a.jpg', 'b.jpg', 'c.jpg']
template = "photo_###"

renamed_files = simulate_file_renaming(filenames, template)

print("Original filenames:", filenames)
print("Renamed files:", renamed_files)

# Function to group anagrams
def group_anagrams(words):
    # Dictionary to hold groups of anagrams
    anagram_groups = {}

    # Iterate through each word in the list
    for word in words:
        # Sort the characters of the word to create a key
        key = "".join(sorted(word))

        # If the key is not in the dictionary, create a new list for this group
        if key not in anagram_groups:
            anagram_groups[key] = []

        # Add the word to the correct group
        anagram_groups[key].append(word)

    # Return the values of the dictionary as a list of lists
    return list(anagram_groups.values())

# Test the function with example input
words1 = ["eat", "tea", "tan", "ate", "nat", "bat"]
grouped_anagrams1 = group_anagrams(words1)
print("Output 1:", grouped_anagrams1)

words2 = ["listen", "silent", "top", "pot", "hello", "world"]
grouped_anagrams2 = group_anagrams(words2)
print("Output 2:", grouped_anagrams2)

# Function to find the maximum subarray sum using Kadane's algorithm
def max_subarray_sum(arr):
    # Initialize variables to keep track of the maximum sum and current sum
    max_sum = float('-inf')  # Start with the smallest possible value
    current_sum = 0

    # Loop through each element in the list
    for num in arr:
        # Add the current number to the current sum
        current_sum += num

        # Update the max sum if the current sum is greater
        if current_sum > max_sum:
            max_sum = current_sum

        # If the current sum becomes negative, reset it to zero
        if current_sum < 0:
            current_sum = 0
    return max_sum
# Test cases
test1 = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
result1 = max_subarray_sum(test1)
print("Output 1:", result1)  # Expected: 6 (subarray [4, -1, 2, 1])

test2 = [1, 2, 3, 4, 5]
result2 = max_subarray_sum(test2)
print("Output 2:", result2)  # Expected: 15 (subarray [1, 2, 3, 4, 5])

# Function to perform a sequential search
def sequential_search(lst, target):
    # Iterate over the list with indices and elements
    for index, item in enumerate(lst):
        # If the current item matches the target, return the index
        if item == target:
            return index

    # If the loop completes and the target is not found, return -1
    return -1

# Example usage
sample_list = [5, 3, 7, 1, 9]
target = 7
# Perform the sequential search
result = sequential_search(sample_list, target)
# Output the result
print(f"Index of target {target}:", result)

def encode(strings):
  encoded_strings = []
  for string in strings:
    length = len(string)
    encoded_strings.append(f"{length}#{string}")
  return "".join(encoded_strings)

def decode(encoded_string):
  decoded_strings = []
  start = 0
  while start < len(encoded_string):
    hash_index = encoded_string.find("#", start)
    length = int(encoded_string[start:hash_index])
    end = hash_index + length + 1
    decoded_strings.append(encoded_string[hash_index + 1:end])
    start = end
  return decoded_strings

# Test cases
print(encode(["hello", "world"]))  # Output: 5#hello5#world
print(decode("3#abc3#def3#ghi"))  # Output: ["abc", "def", "ghi"]

